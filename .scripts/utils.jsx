// helper-functions// http://samuelmullen.com/2012/03/left-pad-zeroes-in-javascript/function zeroPad(value, padding) {	var zeroes = "0";	for (var i = 0; i < padding; i++) { zeroes += "0"; }	return (zeroes + value).slice(padding * -1);}Array.prototype.findUniqueValues = function() {	var o = {}, i, l = this.length, r = [];	for(i=0; i<l;i+=1) o[this[i]] = this[i];	for(i in o) r.push(o[i]);	return r;}function cleanText(text) {	for (var i=0; i < htmlCharacterCodes.length; i++) {		var charCode = htmlCharacterCodes[i];		text = text.replace( new RegExp(htmlCharacterCodes[i][0],'g'), htmlCharacterCodes[i][1] )	};	return text;}function straightenCurlyQuotesInsideAngleBrackets(text) {	// thanks to jashkenas	var tagFinder = /<[^\n]+?>/g;	var quoteFinder = /[“‘’”]([^\n]*?)[“‘’”]/g;	return text.replace(tagFinder, function(tag){		return tag.replace( /[“”]/g , '"' ).replace( /[‘’]/g , "'" );	});}function isEmpty(str) {	return (!str || 0 === str.length);}function isBlank (str) {	return (!str || /^\s*$/.test(str));}function makeKeyword(text) {	// text = text.replace( /[^A-Za-z0-9_\-]/g , "_" ).toLowerCase();	text = text.replace( /[^A-Za-z0-9_\-]/g , "_" );	return text;}function readFile(inputFile,starterText,linePrefix,lineSuffix) {	var outputText = starterText || '';    linePrefix = linePrefix || '';    lineSuffix = lineSuffix || '';	if ( inputFile.exists ) {		inputFile.open("r");		while(!inputFile.eof) {			outputText += linePrefix + inputFile.readln() + lineSuffix;		};		inputFile.close();	} else {		errors.push(inputFile + " could not be found.");	};	return outputText;}function roundTo(numberToRound,decimalPlaces) {	var roundedNumber = Math.round(numberToRound * Math.pow(10,decimalPlaces)) / Math.pow(10,decimalPlaces);	return roundedNumber;}var unlockStuff__lockedObjects = [],    unlockStuff__hiddenObjects = [];function unlockStuff(parentObj) {	if (parentObj.typename=="Layer" || parentObj.typename=="Document") {		for (var layerNo = 0; layerNo < parentObj.layers.length; layerNo++) {			var currentLayer = parentObj.layers[layerNo];			if (currentLayer.locked==true) {				currentLayer.locked = false;				unlockStuff__lockedObjects.push(currentLayer);			};			if (currentLayer.visible==false) {				currentLayer.visible = true;				unlockStuff__hiddenObjects.push(currentLayer);			};			unlockStuff(currentLayer);		};	};	for (var groupItemsNo = 0; groupItemsNo < parentObj.groupItems.length; groupItemsNo++) {		var currentGroupItem = parentObj.groupItems[groupItemsNo];		if (currentGrartoupItem.locked==true) {			currentGroupItem.locked = false;			unlockStuff__lockedObjects.push(currentGroupItem);		};		unlockStuff(currentGroupItem);	};	for (var textFrameNo = 0; textFrameNo < parentObj.textFrames.length; textFrameNo++) {		var currentTextFrame = parentObj.textFrames[textFrameNo];		// this line is producing the MRAP error!!!		if (currentTextFrame.locked==true) {			currentTextFrame.locked = false;			unlockStuff__lockedObjects.push(currentTextFrame);		};	};}var hideTextFrame__textFramesToUnhide = [];function hideTextFrame(textFrame) {	hideTextFrame__textFramesToUnhide.push(textFrame);	textFrame.hidden = true;};function unhideTextFrames() {    // Unhide stuff that was hidden during processing    for (var i = 0; i < hideTextFrame__textFramesToUnhide.length; i++) {        var currentFrameToUnhide = hideTextFrame__textFramesToUnhide[i];        currentFrameToUnhide.hidden = false;    }}function relockStuff() {    // Unhide layers so objects inside can be relocked    for (var i = hiddenObjects.length-1; i>=0; i--) {        unlockStuff__hiddenObjects[i].visible = true;    };    // Relock stuff that was unlocked during processing    for (var i = unlockStuff__lockedObjects.length-1; i>=0; i--) {        unlockStuff__lockedObjects[i].locked = true;    };    // Hide again layers    for (var i = hiddenObjects.length-1; i>=0; i--) {        unlockStuff__hiddenObjects[i].visible = false;    }    }